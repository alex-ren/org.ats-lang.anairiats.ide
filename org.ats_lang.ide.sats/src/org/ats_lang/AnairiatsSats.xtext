grammar org.ats_lang.AnairiatsSats hidden 
    (BLANKS, COMMENT_REST, COMMENT_CLIKE, COMMENT0, COMMENT1, COMMENT_LINE)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore	// required for defining terminal rules

generate anairiatsSats "http://www.ats_lang.org/AnairiatsSats"

satprogram returns satprogram:
    m_sta=d0ecseq_sta
    ;
    

d0ecseq_dyn_rev:
    {d0ecseq_dyn_rev}(m_d0ec_dyn+=d0ec_dyn  semicolonseq)* 
;

d0ec_dyn:
    {d0ec_dyn_d0ec}m_d0ec=d0ec
    | {d0ec_dyn_ext} EXTERN m_kind=dcstkind m_d0ecargseq=d0ecargseq name=d0cstdec m_rec_d0cstdec=andd0cstdecseq
    | {d0ec_dyn_ext_typ} EXTERN TYPEDEF m_str=STRING EQ m_s0exp=s0exp
    | {d0ec_dyn_ext_val}EXTERN 'val' m_str=STRING EQ m_d0exp=d0exp
    | {d0ec_dyn_val} m_valkind=valkind m_v0aldec=v0aldec m_rec_v0aldec=andv0aldecseq
    | {d0ec_dyn_val_par}'val' PAR m_v0aldec=v0aldec m_rec_v0aldec=andv0aldecseq
    | {d0ec_dyn_val_rec}'val' REC m_v0aldec=v0aldec m_rec_v0aldec=andv0aldecseq
    | {d0ec_dyn_fun} m_funkind=funkind m_d0ecargseq=d0ecargseq m_fundec=f0undec m_rec_fundec=andf0undecseq
    | {d0ec_dyn_var}VAR m_v0ardec=v0ardec m_rec_v0ardec=andv0ardecseq
    | {d0ec_dyn_impl}IMPLEMENT m_decseqseq=decs0argseqseq m_i0mpdec=i0mpdec
    | {d0ec_dyn_local}LOCAL m_d0eclocal=d0ecseq_dyn_rev IN m_d0ec_body=d0ecseq_dyn_rev END
    | {d0ec_dyn_extcode}m_literalcode=LITERAL_extcode
    | {d0ec_dyn_srpif}m_ifkind=srpifkind m_guad=guad0ec_dyn
    | {d0ec_dyn_incl}SRPINCLUDE m_include=STRING
    ; /* d0ec_dyn */
    
      
d0ecseq_sta:
    m_d0ecseq_sta_rev=d0ecseq_sta_rev
    ;

d0ecseq_sta_rev:
    {d0ecseq_sta_rev}(m_d0ec_sta+=d0ec_sta  semicolonseq)* 
;

semicolonseq:
    SEMICOLON *;
	
d0ec_sta:
    m_d0ec=d0ec
    | m_kind=dcstkind// fun
      m_tmparg=d0ecargseq  // {n: type}
      name=d0cstdec   // foo {k: int} (x: int k):<fun> int = "xxx"
      m_seq=andd0cstdecseq  // 
    | m_extcode=LITERAL_extcode
    | m_sif=srpifkind m_guad=guad0ec_sta  // #ifdef X #then ... #elif ... #else ... #endif
    | SRPINCLUDE m_include=STRING
    | LOCAL m_local=d0ecseq_sta IN m_body=d0ecseq_sta END
    ;

guad0ec_sta returns guad0ec_sta:
    m_cond=e0xp srpthenopt m_then=d0ecseq_sta
        (((SRPELSE m_else=d0ecseq_sta)? SRPENDIF)
         |srpelifkind m_guad=guad0ec_sta
        )
    ;

srpelifkind:
    SRPELIF  // #elif
    | SRPELIFDEF  // #elifdef
    | SRPELIFNDEF  // #elifndef
    ;

srpthenopt: SRPTHEN?;

srpifkind:
    SRPIF  // #if
    | SRPIFDEF // #ifdef
    | SRPIFNDEF  // #ifndef
    ;

entityname:
    pi0de
;

d0cstdec returns refentity: 
    {d0cstdec}
    name=di0de  // list_insert
    m_d0argseq=d0argseq  // {x: int} (x: int)
    m_col=colonwith  // :<fun>
    m_s0exp=s0exp  // int
    m_extname=extnamopt  // = "foo"
    ;

extnamopt: {extnamopt}(EQ m_str=STRING)?;

colonwith:
    m_colon=COLON  // :
    | m_colonltgt=COLONLTGT  // :<>
    | COLONLT m_eff=e0fftagseq GT  // :<fun>
    ;
    
d0argseq: {d0argseq}(m_args+=d0arg)*;

d0arg:
    name=pi0de
    | m_sta=d0arg_sta
    | m_dyn=d0arg_dyn
    ;

d0arg_dyn: LPAREN m_p0argseq=p0argseq (BAR m_opt=p0argseq)? RPAREN
	;
	
d0arg_sta: LBRACE {d0arg_sta}m_s0quaseq=s0quaseq RBRACE
    ;
	
p0argseq: {p0argseq}(m_first=p0arg m_p0argseqseq_t=commap0argseq)?;

commap0argseq: {commap0argseq}(COMMA m_commaseq+=p0arg)*;

p0arg:
    name=pi0de
    | name=pi0de COLON m_s0exp=s0exp
    ;

// static arguments of function
d0ecargseq: {d0ecargseq}(m_seq_t+=d0ecarg)*;

d0ecarg: 
	LBRACE {d0ecarg} m_s0quaseq=s0quaseq RBRACE
;

//enum dcstkind:
//    FUN='efun'  // fun
//    | VAL='eval'  // val
//    | CASTFN='ecastfn'  // castfn
//    | PRAXI='epraxi'  // praxi
//    | PRFUN='eprfun'  // prfun
//    | PRVAL='eprval'  // prval
//    ;

enum dcstkind:
    FUN='fun'  // fun
    | VAL='val'  // val
    | CASTFN='castfn'  // castfn
    | PRAXI='praxi'  // praxi
    | PRFUN='prfun'  // prfun
    | PRVAL='prval'  // prval
    ;

// the following definition causes java.lang.OutOfMemoryError
//d0ec returns d0ec: 
//    {d0ec_FIXITY} m_fix=INFIX m_p0rec=p0rec m_i0deseq=i0deseq
//    | {d0ec_FIXITY} m_fix=INFIXL m_p0rec=p0rec m_i0deseq=i0deseq
//    | {d0ec_FIXITY} m_fix=INFIXR m_p0rec=p0rec m_i0deseq=i0deseq
//    | {d0ec_FIXITY} m_fix=PREFIX m_p0rec=p0rec m_i0deseq=i0deseq
//    | {d0ec_FIXITY} m_fix=POSTFIX m_p0rec=p0rec m_i0deseq=i0deseq
//    | {d0ec_FIXITY} m_fix=NONFIX m_i0deseq=i0deseq
//    | {d0ec_FIXITY} m_fix=SYMINTR m_i0deseq=i0deseq
//    | {d0ec_SRPDEF} m_def=SRPUNDEF m_i0de=i0de  // #undef i0de
//    | {d0ec_SRPDEF} m_def=SRPDEFINE m_i0de=i0de m_opt=e0xpopt  // #define
//    | {d0ec_SRPOPR} m_opr=SRPASSERT m_e0xp=e0xp  // #assert
//    | {d0ec_SRPOPR} m_opr=SRPERROR m_e0xp=e0xp  // #error
//    | {d0ec_SRPOPR} m_opr=SRPPRINT m_e0xp=e0xp  // #print
//    | {d0ec_SORTDEF} SORTDEF m_d0rtdef=s0rtdef m_sortdef=ands0rtdefseq  // sortdef x = y
//    | {d0ec_DATASORT} m_kind=DATASORT m_d0atsrtdec=d0atsrtdec m_drest=andd0atsrtdecseq  // datasort
//    | {d0ec_DATASORT} m_kind=DATAPARASORT m_d0atsrtdec=d0atsrtdec m_drest=andd0atsrtdecseq
//    | {d0ec_abskind} m_kind=abskind m_s0tacon=s0tacon m_abskind=ands0taconseq  // absviewtype xxptr (l: addr)
//    | {d0ec_STA0} STA m_s0tacst=s0tacst m_srest=ands0tacstseq
//    | {d0ec_STAVAR} STAVAR m_s0tavar=s0tavar m_srest=ands0tavarseq
//    | {d0ec_STADEF} m_kind=stadefkind m_s0expdef=s0expdef m_seq_stadefkind=ands0expdefseq  // typedef T (int n) = [k: int | k > n] int k
//    | {d0ec_ASSUME} ASSUME m_s0asdec=s0aspdec  // assume T = int
//    | {d0ec_datakind} m_kind=datakind m_d0atdec=d0atdec m_datatype=andd0atdecseq m_opt=s0expdefseqopt  
//    | {d0ec_EXCEPTION} EXCEPTION m_e0xndec=e0xndec m_exception=ande0xndecseq
//    | {d0ec_CLASSDEC} CLASSDEC m_si0de=si0de (COLON m_s0exp=s0exp)?
//    | {d0ec_OVERLOAD} OVERLOAD m_di0de=di0de WITH m_dqi0de=dqi0de
//    | {d0ec_OVERLOAD} OVERLOAD LBRACKET RBRACKET WITH m_dqi0de=dqi0de
//    | {d0ec_MACRODEF} m_kind=MACDEF m_isrec?=REC? m_m0acdef=m0acdef m_seq_t=andm0acdefseq
//    | {d0ec_MACRODEF} m_kind=MACRODEF m_isrec?=REC? m_m0acdef=m0acdef m_seq_t=andm0acdefseq
//    | {d0ec_DYNLOAD} DYNLOAD importURI=STRING
//    | {d0ec_STALOAD} STALOAD importURI=STRING
//    | {d0ec_STALOAD} STALOAD m_stai0de=stai0de EQ importURI=STRING
//    ;

d0ec: 
	{d0ec}
	(
    m_kind=INFIX m_p0rec=p0rec m_i0deseq=i0deseq
    | m_kind=INFIXL m_p0rec=p0rec m_i0deseq=i0deseq
    | m_kind=INFIXR m_p0rec=p0rec m_i0deseq=i0deseq
    | m_kind=PREFIX m_p0rec=p0rec m_i0deseq=i0deseq
    | m_kind=POSTFIX m_p0rec=p0rec m_i0deseq=i0deseq
    | m_kind=NONFIX m_i0deseq=i0deseq
    | m_kind=SYMINTR m_i0deseq=i0deseq
    | m_kind=SRPUNDEF m_i0de=i0de  // #undef i0de
    | m_kind=SRPDEFINE m_def_refi0de=refi0de m_opt=e0xpopt  // #define
    | m_kind=SRPASSERT m_e0xp=e0xp  // #assert
    | m_kind=SRPERROR m_e0xp=e0xp  // #error
    | m_kind=SRPPRINT m_e0xp=e0xp  // #print
    | m_kind=SORTDEF m_d0rtdef=s0rtdef m_sortdef=ands0rtdefseq  // sortdef x = y
    | m_kind=DATASORT m_d0atsrtdec=d0atsrtdec m_drest=andd0atsrtdecseq  // datasort
    | m_kind=DATAPARASORT m_d0atsrtdec=d0atsrtdec m_drest=andd0atsrtdecseq
    | m_kind=abskind m_s0tacon=s0tacon m_abskind=ands0taconseq  // absviewtype xxptr (l: addr)
    | m_kind=STA m_s0tacst=s0tacst m_srest=ands0tacstseq
    | m_kind=STAVAR m_s0tavar=s0tavar m_s0tavarseq=ands0tavarseq
    | m_kind=stadefkind m_s0expdef=s0expdef m_seq_stadefkind=ands0expdefseq  // typedef T (int n) = [k: int | k > n] int k
    | m_kind=ASSUME m_s0asdec=s0aspdec  // assume T = int
    | m_kind=datakind m_d0atdec=d0atdec m_datatype=andd0atdecseq m_s0expdefseqopt=s0expdefseqopt  
    | m_kind=EXCEPTION m_e0xndec=e0xndec m_exception=ande0xndecseq  // exception
    | m_kind=CLASSDEC m_si0de=si0de (COLON m_s0exp=s0exp)?
    | m_kind=OVERLOAD m_di0de=refdi0de WITH m_dqi0de=[refentity|dqi0de]  // overload
    | m_kind=OVERLOAD LBRACKET RBRACKET WITH m_dqi0de=[refentity|dqi0de]  // overload
    | m_kind=MACDEF m_m0acdef=m0acdef m_seq_t=andm0acdefseq  // macdef
    | m_kind=MACDEF REC m_m0acdef=m0acdef m_seq_t=andm0acdefseq  // macdef
    | m_kind=MACRODEF m_m0acdef=m0acdef m_seq_t=andm0acdefseq  // macdef
    | m_kind=MACRODEF REC m_m0acdef=m0acdef m_seq_t=andm0acdefseq  // macdef
// one kind of strategy
//    | m_kind=DYNLOAD filename=STRING  // don't import
//    | m_kind=STALOAD importURI=SATS_STRING
//    | m_kind=STALOAD filename=STRING
//    | m_kind=STALOAD m_stai0de=stai0de EQ importURI=SATS_STRING
//    | m_kind=STALOAD m_stai0de=stai0de EQ filename=STRING

    | m_kind=DYNLOAD importURI=STRING
    | m_kind=STALOAD importURI=STRING
    | m_kind=STALOAD m_stai0de=stai0de EQ importURI=STRING
    )
    ;

stai0de: ALNUMRIC_IDENTIFIER;

andm0acdefseq: {andm0acdefseq}(AND m_seq_t+=m0acdef)*;


m0acdef returns refentity:
    {m0acdef} name=di0de m_mac=m0acargseq EQ m_d0exp=d0exp
    ;

// quite different from the origin due to handle of case
// origin
//d0exp ::= 
//  | atmd0exp argd0expseq
//  | d0exp ":" s0exp
//  | ifhead d0exp "then" d0exp
//  | ifhead d0exp "then" d0exp "else" d0exp
//  | sifhead s0exp "then" d0exp "else" d0exp
//  | casehead d0exp "of" c0lauseq
//  | scasehead s0exp "of" sc0lauseq
//  | lamkind f0arg1seq colons0expopt funarrow d0exp
//  | fixkind di0de f0arg1seq colons0expopt funarrow d0exp
//  | forhead initestpost d0exp
//  | whilehead atmd0exp d0exp
//  | "$raise" d0exp
//  | tryhead d0expsemiseq0 "with" c0lauseq
//  | d0exp "where" "{" d0ecseq_dyn "}"
d0exp returns d0exp: 
    {d0expbasetype} m_base=d0expbase 
    | {d0expcasetype}(m_d=d0expcase | m_s=s0expcase)  dcase=d0expgo
//    | m_s=s0expcase scase=s0expgo
    |{d0exp_trytype}m_t=t0exptry tcase=d0expgo
    ;

d0expcase: 
	m_ch=casehead m_d0expcase=d0exp OF
    ;

s0expcase: 
	m_sh=scasehead m_s0expcase=s0exp OF
    ;

t0exptry: tryhead m_t0expcase=d0expsemiseq0 WITH
    ;
    
//    d0expbase:
//    // different from desc
//    m_seq1=argd0expseq1 (COLON m_s0exp=s0exp)? 
//        (WHERE LBRACE m_d0ecseq=d0ecseq_dyn RBRACE)?
//    // very brute solution: must write else
//    | m_dhead=ifhead m_dcond=d0exp THEN m_dthen=d0exp ELSE m_delse=d0exp
//    | m_shead=sifhead m_scond=s0exp THEN m_sthen=d0exp ELSE m_selse=d0exp
//    | lamkind m_d0arg1seq=f0arg1seq m_lamopt=colons0expopt m_funarr=funarrow m_lambody=d0exp
//    | fixkind m_di0de=di0de m_f0arg1seq=f0arg1seq m_fixopt=colons0expopt m_funarr=funarrow m_fixbody=d0exp
////  | forhead initestpost d0exp  todo not support now
////  | whilehead atmd0exp d0exp  todo not support now
//    | DLRRAISE m_raise=d0exp
//    ;

    
    
d0expcommabarsemiseqi: {d0expcommabarsemiseqi}
	(m_d0expi=d0expi m_d0expseq=commabarsemid0expseq)?
;
    
d0expbasei:
    // different from desc
    m_seq1=argd0expseq1i (COLON m_s0exp=s0exp)? 
        (WHERE LBRACE m_d0ecseq=d0ecseq_dyn_rev RBRACE)?
    // very brute solution: must write else
    | m_dhead=ifhead m_dcond=d0exp THEN m_dthen=d0expi (=>ELSE m_delse=d0expi)?
    | m_shead=sifhead m_scond=s0exp THEN m_sthen=d0expi (=>ELSE m_selse=d0expi)?
    | lamkind m_d0arg1seq=f0arg1seq m_lamopt=colons0expopt m_funarr=funarrow m_lambody=d0expi
    | fixkind m_di0de=di0de m_f0arg1seq=f0arg1seq m_fixopt=colons0expopt m_funarr=funarrow m_fixbody=d0expi
    | m_forhead=forhead m_post=initestpost m_body=d0exp  // todo not support now
    | m_whilehead=whilehead m_atm=atmd0exp m_exp=d0exp  //   todo not support now
    | DLRRAISE m_raise=d0expi
    ;


d0expi:
	m_base=d0expbasei
    | LPAREN m_d=d0expcase dcase=d0expgo RPAREN
    
//    | m_s=s0expcase scase=s0expgo
//    | m_t=t0exptry tcase=d0expgo
;

atmp0ati:
    name=LITERAL_char
    | name=LITERAL_int
    | name=LITERAL_float
    | name=STRING
    | name=pi0de
    | BANG name=pi0de
    | OP name=pi0de
    | m_d0ynq=d0ynq name=pi0de
    | LPAREN m_p0atseq=p0atseqi RPAREN  // should be allowed
    | QUOTELBRACKET m_p0atseq=p0atseq RBRACKET
    | ATLPAREN m_p0atseq=p0atseq RPAREN
    | QUOTELPAREN m_p0atseq=p0atseq RPAREN
    | ATLBRACE m_labp0atseq=labp0atseq RBRACE
    | QUOTELBRACE m_labp0atseq=labp0atseq RBRACE
    | LBRACKET m_s0argseq=s0argseq RBRACKET
    
    ;


p0atseqi: {p0atseqi}(m_p0at=p0at m_p0atseq=commap0atseq /* origin is commap0atseq */)?;

commap0atseq: {commap0atseq}(COMMA m_commap0atseq+=p0at)*;

 
guap0ati: m_p0at=p0ati (WHEN m_guap0at=m0atchseq)?
    ;

p0ati:
    (pi0de AS|BANG pi0de AS |TILDE)*
        name=atmp0ati m_p0atargseq=argp0atseq (COLON m_s0exp=s0exp)?
    ;

d0expgo:
    =>BAR (m_guap0at=guap0at)  (EQGT|EQGTGT|EQSLASHEQGT|EQSLASHEQGTGT) 
      (m_dbase=d0expbasei m_dgo=d0expgo?
       | m_dcase=d0expcase m_dgo=d0expgo
       | LPAREN m_dcase=d0expcase m_dgo=d0expgo RPAREN (COLON m_s0exp=s0exp)? 
       | m_scase=s0expcase m_sgo=d0expgo  // s0expgo
       | LPAREN m_scase=s0expcase m_sgo=d0expgo RPAREN  // s0expgo
       | m_tcase=t0exptry m_tgo=d0expgo)
       
    ;

//s0expgo:
//    BAR m_sp0at=sp0at EQGT
//      (m_dbase=d0expbasei m_sgo=s0expgo?
//       | m_scase=s0expcase m_sgo=s0expgo
//       | m_dcase=d0expcase m_dgo=d0expgo
//       | m_tcase=t0exptry m_tgo=d0expgo)
//    ;

sp0at: m_sqi0de=sqi0de LPAREN m_seq=s0argseq RPAREN
    ;
 
d0expbase:
    // different from desc
    m_seq1=argd0expseq1 (COLON m_s0exp=s0exp)? 
        (WHERE LBRACE m_d0ecseq=d0ecseq_dyn_rev RBRACE)?
    | m_dhead=ifhead m_dcond=d0exp THEN m_dthen=d0exp (=>ELSE m_delse=d0exp)?
    | m_shead=sifhead m_scond=s0exp THEN m_sthen=d0exp (=>ELSE m_selse=d0exp)?
    | lamkind m_d0arg1seq=f0arg1seq m_lamopt=colons0expopt m_funarr=funarrow m_lambody=d0exp
    | fixkind m_di0de=di0de m_f0arg1seq=f0arg1seq m_fixopt=colons0expopt m_funarr=funarrow m_fixbody=d0exp
    | m_forhead=forhead m_post=initestpost m_body=d0exp  // todo not support now
    | m_whilehead=whilehead m_atm=atmd0exp m_exp=d0exp  //   todo not support now
    | DLRRAISE m_raise=d0exp
    ;

whilehead: WHILESTAR m_loopinv=loopi0nv EQGT
; /* whilehead */


forhead: {forhead} FOR
  | {forhead} FORSTAR m_loopinv=loopi0nv EQGT
; /* forhead */

loopi0nv:
	m_qua=i0nvqua m_met=i0nvmet m_varsta=i0nvargstate m_ressta=i0nvresstate
;

i0nvqua: {i0nvqua} (LBRACE m_seq=s0quaseq RBRACE)?
; /* i0nvqua */

i0nvmet: {i0nvmet}(DOTLT m_seq=s0expseq GTDOT)?
; /* i0nvmet */

i0nvargstate: LPAREN m_seq=i0nvargseq RPAREN
;

initestpost: LPAREN m_seq1=d0expcommaseq SEMICOLON m_seq2=d0expcommaseq SEMICOLON m_seq3=d0expcommaseq RPAREN
; /* initestpost */



//sc0lauseq:
//    (sc0lau)? barsc0lauseq
//    ;

tryhead: TRY  // try
    ;

fixkind:
    FIX  // "fix"
    | ATFIX  // "@fix"
    ; /* fixkind */


lamkind:
    LAM  // "lam"
    | ATLAM  // "@lam"
    | LLAM  // "llam"
    | ATLLAM  // "@llam"
    ;

funarrow:
    m_eqgt=EQGT  // "=>"
    | m_eqltgt=EQLTGT  // "=<>"
    | EQLT m_eff=e0fftagseq GT  // "=<" e0fftagseq ">"
    ;

scasehead: SCASE caseinv;

casehead:
    m_pre=CASE m_case=caseinv
    | m_pre=CASEMINUS m_case=caseinv
    | m_pre=CASEPLUS m_case=caseinv
    ;
    
//c0lauseq:
//    c0lau? m_c0lauseq=barc0lauseq
//    ;
//
//barc0lauseq: (BAR m_barc0lauseq+=c0lau)*;
//
//c0lau: guap0at (EQGT|EQGTGT|EQSLASHEQGT|EQSLASHEQGTGT) m_c0laud0exp=d0exp
//    ;

guap0at: m_p0at=p0at (WHEN m_guap0at=m0atchseq)?
    ;

//guap0atgo: m_p0at=p0at (WHEN m_guap0at=m0atchseq)?
//    ;
    
m0atchseq: 
	m_match=m0atch m_m0atchseq=andm0atchseq
;

andm0atchseq: {andm0atchseq}(AND m_andm0atchseq+=m0atch)*;

m0atch: m_m0atchd0exp=d0exp (AS m_m0atch=p0at)?
    ;

sifhead: SIF caseinv;

ifhead: IF caseinv; // if :[...](...) =>

caseinv: {caseinv}(m_i0nvresstate=i0nvresstate EQGT)?;

i0nvresstate: 
    {i0nvresstate}(COLON m_i0nresqua=i0nvresqua 
    	LPAREN m_i0nvresstate=i0nvargseq RPAREN
    )?
    ;

i0nvargseq: {i0nvargseq}(m_i0nvarg=i0nvarg m_i0nvargseq=commai0nvargseq)?;

commai0nvargseq: {commai0nvargseq}(COMMA m_i0nvargseq+=i0nvarg)*;

i0nvarg returns refentity: {i0nvarg} name=di0de COLON m_s0exp=s0exp?;

i0nvresqua: {i0nvresqua}(LBRACKET m_s0quaseq=s0quaseq RBRACKET)?;


argd0expseq1: (m_argd0expseq+=argd0exp)+;
argd0expseq1i: (m_argd0expseq+=argd0expi)+;

argd0exp:
    m_d0exp=atmd0exp_argd0exp  // origin is atmd0exp
    | m_s0exparg=s0expdarg
    ; /* argd0exp */

argd0expi:
    m_d0exp=atmd0exp_argd0expi  // origin is atmd0exp
    | m_s0exparg=s0expdarg
    ; /* argd0exp */
    
// The following one is a little bit different from atmd0exp in
// rules "FOLDAT" and "FREEAT"
atmd0exp_argd0exp returns atmd0exp_argd0exp:
    LPAREN m_semiseq=d0expcommabarsemiseq /*origin is d0expcommaseq*/ RPAREN
      
    // shared by atmd0exp_argd0exp and atmd0exp_argd0expi  
    | m_di0de=[refentity|di0de]
    | OP m_di0de=[refentity|di0de]
    | m_d0ynq=d0ynq m_id0de=i0de
    // end of [shared by atmd0exp_argd0exp and atmd0exp_argd0expi]
      
    // shared by atmd0exp, atmd0exp_argd0exp and atmd0exp_argd0expi  
    | m_val=LITERAL_char
    | m_val=LITERAL_float
    | m_val=LITERAL_floatsp
    | m_val=LITERAL_int
    | m_val=LITERAL_intsp
    | m_val=STRING
//    | m_val=SATS_STRING
    | m_content=SRPFILENAME // #FILENAME
    | m_content=SRPLOCATION  // #LOCATION
    | m_d0dext=i0dext
    | m_content=AMPERSAND  // &
    | m_content=BREAK  // break
    | m_content=CONTINUE // continue
    | m_content=FOLDAT /* remove s0expdargseq*/
    | m_content=FREEAT /* remove s0expdargseq*/
    | m_content=VIEWAT
    | m_content=DLRDECRYPT  // $decrypt
    | m_content=DLRENCRYPT  // $encrypt
    | m_content=DLRDELAY // $delay
    | m_content=DLRLDELAY  // $ldelay
    | m_content=DLRDYNLOAD  // $dynload
    | m_content=DLREFFMASK_ALL  // $effmask_all
    | m_content=DLREFFMASK_EXN   // $effmask_exn
    | m_content=DLREFFMASK_NTM // $effmask_ntm
    | m_content=DLREFFMASK_REF  // $effmask_ref
    | ATLBRACKET m_s0exp=s0exp RBRACKET (LBRACKET m_d0expopt=d0exp RBRACKET)? LPAREN m_seqat=d0expcommaseq RPAREN
    | DLRARRSZ m_s0expelt=s0expelt LPAREN m_arr=d0expcommaseq RPAREN  // $arrsz
    | m_arrqi0de=arrqi0de m_d0arrind=d0arrind
    | m_s0elop=s0elop l0ab
    | m_s0elop=s0elop LBRACKET m_d0arrind=d0arrind
    | m_tmpqi0de=tmpqi0de m_t1mpsseq=t1mps0expseq m_tmp_sq_t=gtlt_t1mps0expseqseq GT  // related to template
    | HASHLBRACKET m_s0exparg=s0exparg BAR m_hashlbracketd0xp=d0exp RBRACKET
    | DLRLST /*$lst_t*/ m_s0expelt=s0expelt LPAREN m_dlrlst=d0expcommaseq RPAREN
    | DLRLST_VT /*$lst_vt*/ m_s0expelt=s0expelt LPAREN m_dlrlst_vt=d0expcommaseq RPAREN
    | QUOTELBRACKET /*'[*/ m_d0expseq=d0expcommaseq RBRACKET
    | BEGIN m_d0expseq0=d0expsemiseq0 END
//    | LPAREN d0expcommabarsemiseq RPAREN  // origin is d0expsemiseq1 // no need any more
    | ATLPAREN m_d0expcommabarseq=d0expcommabarseq /* origin is d0expcommaseq*/ RPAREN
    | QUOTELPAREN /* '( */ m_d0expcommabarseq=d0expcommabarseq /* origin is d0expcommaseq*/ RPAREN
    | DLRTUP_T LPAREN m_d0expcommabarseq=d0expcommaseq RPAREN
    | DLRTUP_VT LPAREN m_d0expcommabarseq=d0expcommaseq RPAREN
//    | "@(" d0expcommaseq "|" d0expcommaseq ")"  // no need
//    | "'(" d0expcommaseq "|" d0expcommaseq ")"  // no need
    | ATLBRACE m_labd0expseq=labd0expseq RBRACE
    | QUOTELBRACE m_labd0expseq=labd0expseq RBRACE
    | DLRREC_T LBRACE m_labd0expseq=labd0expseq RBRACE
    | DLRREC_VT LBRACE m_labd0expseq=labd0expseq RBRACE
    | DLREXTVAL LPAREN m_s0exp=s0exp COMMA STRING RPAREN
    | PERCENTLPAREN /* %( */ m_d0exp=d0exp RPAREN
    | COMMALPAREN /* ,( */ m_d0exp=d0exp RPAREN
    | BACKQUOTELPAREN /* `( */ m_d0expseq0=d0expsemiseq0 RPAREN
    | LET {atmd0exp_argd0exp_let} m_seq_dyn=d0ecseq_dyn_rev IN m_d0explet=d0expsemiseq0 END
    | LBRACE m_seq_dyn=d0ecseq_dyn_rev RBRACE
    // end of [shared by atmd0exp, atmd0exp_argd0exp and atmd0exp_argd0expi] 
    ; /* atmd0exp_argd0exp */
    

atmd0exp_argd0expi returns atmd0exp_argd0expi:
    // change d0expcommabarsemiseq to d0expcommabarsemiseqi
     LPAREN m_semiseq=d0expcommabarsemiseqi /*origin is d0expcommaseq*/ RPAREN
     
    // shared by atmd0exp_argd0exp and atmd0exp_argd0expi  
    | m_di0de=[refentity|di0de]
    | OP m_di0de=[refentity|di0de]
    | m_d0ynq=d0ynq m_id0de=i0de
    // end of [shared by atmd0exp_argd0exp and atmd0exp_argd0expi]

    // shared by atmd0exp, atmd0exp_argd0exp and atmd0exp_argd0expi 
    | m_content=LITERAL_char
    | m_content=LITERAL_float
    | m_content=LITERAL_floatsp
    | m_content=LITERAL_int
    | m_content=LITERAL_intsp
    | m_content=STRING
    | m_content=SRPFILENAME // #FILENAME
    | m_content=SRPLOCATION  // #LOCATION
    | m_d0dext=i0dext
    | m_content=AMPERSAND  // &
    | m_content=BREAK  // break
    | m_content=CONTINUE // continue
    | m_content=FOLDAT /* remove s0expdargseq*/
    | m_content=FREEAT /* remove s0expdargseq*/
    | m_content=VIEWAT
    | m_content=DLRDECRYPT  // $decrypt
    | m_content=DLRENCRYPT  // $encrypt
    | m_content=DLRDELAY // $delay
    | m_content=DLRLDELAY  // $ldelay
    | m_content=DLRDYNLOAD  // $dynload
    | m_content=DLREFFMASK_ALL  // $effmask_all
    | m_content=DLREFFMASK_EXN   // $effmask_exn
    | m_content=DLREFFMASK_NTM // $effmask_ntm
    | m_content=DLREFFMASK_REF  // $effmask_ref
    | ATLBRACKET m_s0exp=s0exp RBRACKET (LBRACKET m_d0expopt=d0exp RBRACKET)? LPAREN m_seqat=d0expcommaseq RPAREN
    | DLRARRSZ m_s0expelt=s0expelt LPAREN m_arr=d0expcommaseq RPAREN  // $arrsz
    | m_arrqi0de=arrqi0de m_d0arrind=d0arrind
    | m_s0elop=s0elop l0ab
    | m_s0elop=s0elop LBRACKET m_d0arrind=d0arrind
    | m_tmpqi0de=tmpqi0de m_t1mpsseq=t1mps0expseq m_tmp_sq_t=gtlt_t1mps0expseqseq GT  // related to template
    | HASHLBRACKET m_s0exparg=s0exparg BAR m_hashlbracketd0xp=d0exp RBRACKET
    | DLRLST /*$lst_t*/ m_s0expelt=s0expelt LPAREN m_dlrlst=d0expcommaseq RPAREN
    | DLRLST_VT /*$lst_vt*/ m_s0expelt=s0expelt LPAREN m_dlrlst_vt=d0expcommaseq RPAREN
    | QUOTELBRACKET /*'[*/ m_d0expseq=d0expcommaseq RBRACKET
    | BEGIN m_d0expseq0=d0expsemiseq0 END
//    | LPAREN d0expcommabarsemiseqi RPAREN  // origin is d0expsemiseq1 // no need any more
    | ATLPAREN m_d0expcommabarseq=d0expcommabarseq /* origin is d0expcommaseq*/ RPAREN
    | QUOTELPAREN /* '( */ m_d0expcommabarseq=d0expcommabarseq /* origin is d0expcommaseq*/ RPAREN
    | DLRTUP_T LPAREN m_d0expcommabarseq=d0expcommaseq RPAREN
    | DLRTUP_VT LPAREN m_d0expcommabarseq=d0expcommaseq RPAREN
//    | "@(" d0expcommaseq "|" d0expcommaseq ")"  // no need
//    | "'(" d0expcommaseq "|" d0expcommaseq ")"  // no need
    | ATLBRACE m_labd0expseq=labd0expseq RBRACE
    | QUOTELBRACE m_labd0expseq=labd0expseq RBRACE
    | DLRREC_T LBRACE m_labd0expseq=labd0expseq RBRACE
    | DLRREC_VT LBRACE m_labd0expseq=labd0expseq RBRACE
    | DLREXTVAL LPAREN m_s0exp=s0exp COMMA STRING RPAREN
    | PERCENTLPAREN /* %( */ m_d0exp=d0exp RPAREN
    | COMMALPAREN /* ,( */ m_d0exp=d0exp RPAREN
    | BACKQUOTELPAREN /* `( */ m_d0expseq0=d0expsemiseq0 RPAREN
    | LET {atmd0exp_argd0expi_let} m_seq_dyn=d0ecseq_dyn_rev IN m_d0explet=d0expsemiseq0 END
    | LBRACE m_seq_dyn=d0ecseq_dyn_rev RBRACE
    // end of [shared by atmd0exp, atmd0exp_argd0exp and atmd0exp_argd0expi] 
    ; /* atmd0exp_argd0expi */
    
atmd0exp returns atmd0exp: 
    LPAREN m_d0expcommabarsemiseq=d0expcommabarsemiseq /*origin is d0expcommaseq*/ RPAREN
    // shared by atmd0exp, atmd0exp_argd0exp and atmd0exp_argd0expi
    | m_lichar=LITERAL_char
    | m_x=LITERAL_float
    | m_x=LITERAL_floatsp
    | m_x=LITERAL_int
    | m_x=LITERAL_intsp
    | m_x=STRING
    | m_x=SRPFILENAME  // #FILENAME
    | m_x=SRPLOCATION  // #LOCATION
    | m_x=di0de
    | OP m_x=di0de
    | m_d0ynq=d0ynq m_x=i0de
    | m_x=i0dext
    | m_x=AMPERSAND  // &
    | m_x=BREAK  // break
    | m_x=CONTINUE  // continue
    | m_x=FOLDAT m_s0expdargseq=s0expdargseq
    | m_x=FREEAT m_s0expdargseq=s0expdargseq
    | m_x=VIEWAT
    | m_x=DLRDECRYPT  // $decrypt
    | m_x=DLRENCRYPT  // $encrypt
    | m_x=DLRDELAY  // $delay
    | m_x=DLRLDELAY  // $ldelay
    | m_x=DLRDYNLOAD  // $dynload
    | m_x=DLREFFMASK_ALL  // $effmask_all
    | m_x=DLREFFMASK_EXN  // $effmask_exn
    | m_x=DLREFFMASK_NTM  // $effmask_ntm
    | m_x=DLREFFMASK_REF  // $effmask_ref
    | ATLBRACKET m_s0exp=s0exp RBRACKET (LBRACKET m_d0expopt=d0exp RBRACKET)? LPAREN m_seqat=d0expcommaseq RPAREN
    | DLRARRSZ m_spexpelt=s0expelt LPAREN m_arr=d0expcommaseq RPAREN  // $arrsz
    | m_arrqi0de=arrqi0de m_d0arrind=d0arrind
    | m_s0elop=s0elop m_l0ab=l0ab
    | m_s0elop=s0elop LBRACKET m_d0arrind=d0arrind
    | m_tmpqi0de=tmpqi0de m_t1mpsseq=t1mps0expseq m_tmp_sq_t=gtlt_t1mps0expseqseq GT  // related to template
    | HASHLBRACKET m_s0exparg=s0exparg BAR m_hashlbracketd0xp=d0exp RBRACKET
    | DLRLST /*$lst_t*/ m_s0expelt=s0expelt LPAREN m_dlrlst=d0expcommaseq RPAREN
    | DLRLST_VT /*$lst_vt*/ m_s0expelt=s0expelt LPAREN m_dlrlst_vt=d0expcommaseq RPAREN
    | QUOTELBRACKET /*'[*/ m_commaseq=d0expcommaseq RBRACKET
    | BEGIN m_semiseq0=d0expsemiseq0 END
//    | LPAREN d0expcommabarsemiseq RPAREN  // origin is d0expsemiseq1 // no need any more
    | ATLPAREN m_commabarseq=d0expcommabarseq /* origin is d0expcommaseq*/ RPAREN
    | QUOTELPAREN /* '( */ m_commabarseq=d0expcommabarseq /* origin is d0expcommaseq*/ RPAREN
    | DLRTUP_T LPAREN m_commaseq=d0expcommaseq RPAREN
    | DLRTUP_VT LPAREN m_commaseq=d0expcommaseq RPAREN
//    | "@(" d0expcommaseq "|" d0expcommaseq ")"  // no need
//    | "'(" d0expcommaseq "|" d0expcommaseq ")"  // no need
    | ATLBRACE m_labd0expseq=labd0expseq RBRACE
    | QUOTELBRACE m_labd0expseq=labd0expseq RBRACE
    | DLRREC_T LBRACE m_labd0expseq=labd0expseq RBRACE
    | DLRREC_VT LBRACE m_labd0expseq=labd0expseq RBRACE
    | DLREXTVAL LPAREN m_s0exp=s0exp COMMA STRING RPAREN
    | PERCENTLPAREN /* %( */ m_d0exp=d0exp RPAREN
    | COMMALPAREN /* ,( */ m_d0exp=d0exp RPAREN
    | BACKQUOTELPAREN /* `( */ m_d0expseq=d0expsemiseq0 RPAREN
    | LET {atmd0exp_let} m_d0ecseq=d0ecseq_dyn_rev IN m_d0explet=d0expsemiseq0 END
    | LBRACE m_d0ecseq=d0ecseq_dyn_rev RBRACE
    // end of [shared by atmd0exp, atmd0exp_argd0exp and atmd0exp_argd0expi] 
    ; /* atmd0exp */


guad0ec_dyn:
    m_cond=e0xp srpthenopt m_then=d0ecseq_dyn_rev
        (((SRPELSE m_else=d0ecseq_dyn_rev)? SRPENDIF)
         |srpelifkind m_guad=guad0ec_dyn
        )
    ;
    
i0mpdec:
    m_imp=impqi0de m_i0mpdec=f0arg2seq m_expopt=colons0expopt EQ m_i0mpdecd0exp=d0exp
    ;

colons0expopt: {colons0expopt}(COLON m_s0exp=s0exp)?;

f0arg2seq: {f0arg2seq}(m_f0arg2seq+=f0arg2)*;

f0arg2:
    LBRACE m_s0argseq=s0argseq RBRACE
    | m_atmp0at=atmp0at
    ;


impqi0de:
    name=[refentity|dqi0de]
    | name=[refentity|tmpqi0de] m_t1mpseq=t1mps0expseq m_impqi0de=gtlt_t1mps0expseqseq GT
    ;



decs0argseqseq: {decs0argseqseq}(LBRACE m_seq=decs0argseq RBRACE m_seqseq=decs0argseqseq)?;

decs0argseq: {decs0argseq}(m_s0arg=s0arg m_rest=commadecs0argseq)?;

commadecs0argseq: {commadecs0argseq}(COMMA m_args+=s0arg)*;



andv0ardecseq: {andv0ardecseq}(AND m_v0ardec+=v0ardec)*;

v0ardec returns refentity:
    {v0ardec} 
    (BANG name=pi0de m_v0arwth=v0arwth EQ m_d0exp=d0exp
    | name=pi0de (m_v0arwth=v0arwth EQ m_d0exp=d0exp
             | COLON m_s0exp=s0exp m_v0arwth=v0arwth (EQ m_v0ardef_d0exp=d0exp)?
            )
    )
; /* v0ardec */

v0arwth: {v0arwth}(WITH name=pi0de)?;

andf0undecseq: {andf0undecseq}(AND m_f0undec+=f0undec)*;

f0undec returns refentity: {f0undec}
    OP? name=di0de args=f0arg1seq (m_colon=colonwith m_f0undec_s0exp=s0exp)? 
      EQ m_f0undec_d0xp=d0exp m_f0undef_type=witht0ype
    ;

//fi0de:
//    name=di0de
//    | OP name=di0de
//    ;
    
f0arg1seq: {f0arg1seq}(m_f0arg1seq+=f0arg1)*
    ;

f0arg1 returns f0arg1:
    m_f0arg1_sta=f0arg1_sta
    | m_atmp0at=atmp0at
    | DOTLT m_s0expseq=s0expseq GTDOT
    | DOTLTGTDOT{f0arg1}
    ;

f0arg1_sta:
	LBRACE m_s0quaseq=s0quaseq RBRACE
;

funkind:
    FN  // fn
    | FNSTAR  // fn*
    | 'fun'  // fun
    | 'castfn'  // "castfn
    | PRFN  // prfn
    | 'prfun'  // prfun
    ;
    
valkind:
    'val'
    | VALMINUS
    | VALPLUS
    | 'prval'
    ;
    
andv0aldecseq: {andv0aldecseq}(AND m_andv0aldecseq+=v0aldec)*
    ;

v0aldec: name=p0at EQ m_d0exp=d0exp m_witht0ype=witht0ype
    ;

witht0ype:{witht0ype}
    (WITHPROP m_s0exp=s0exp 
    | WITHTYPE m_s0exp=s0exp
    | WITHVIEW m_s0exp=s0exp
    | WITHVIEWTYPE m_s0exp=s0exp
    )?;

// Origin is
//p0at ::= 
//  | atmp0at argp0atseq
//  | p0at ":" s0exp
//  | pi0de "as" p0at
//  | "!" pi0de "as" p0at
//  | "~" p0at
//; /* p0at */

p0at:
    (pi0de AS|BANG pi0de AS |TILDE)*
        name=atmp0at m_p0atargseq=argp0atseq (COLON (m_s0exp=s0exp))?
    ;
    
p0atgo:
    (pi0de AS|BANG pi0de AS |TILDE)*
        name=atmp0at m_p0atargseq=argp0atseq (COLON (m_s0exp=s0exp))?
    ;

atmp0at returns refentity:
    {literal_atmp0at}literal_name=LITERAL_char
    | {literal_atmp0at}literal_name=LITERAL_int
    | {literal_atmp0at}literal_name=LITERAL_float
    | {literal_atmp0at}literal_name=STRING
    | {simple_atmp0at}name=pi0de  // was pi0de
    | {simple_atmp0at}BANG name=pi0de  // was pi0de
    | {simple_atmp0at}OP name=pi0de  // was pi0de
    | {simple_atmp0at}m_d0ynq=d0ynq name=pi0de  // was pi0de
    | {compound_atmp0at}LPAREN m_p0atseq=p0atseq RPAREN
    | {compound_atmp0at}QUOTELBRACKET m_p0atseq=p0atseq RBRACKET
    | {compound_atmp0at}ATLPAREN m_p0atseq=p0atseq RPAREN
    | {compound_atmp0at}QUOTELPAREN m_p0atseq=p0atseq RPAREN
    | {compound_atmp0at}ATLBRACE m_labp0atseq=labp0atseq RBRACE
    | {compound_atmp0at}QUOTELBRACE m_labp0atseq=labp0atseq RBRACE
    | {compound_atmp0at}LBRACKET m_s0argseq=s0argseq RBRACKET
    ; /* atmp0at */
//
//atmp0atgo:
//    name=LITERAL_char
//    | name=LITERAL_int
//    | name=LITERAL_float
//    | name=STRING
//    | name=pi0de // (kk=colons0rtopt)?
//    | BANG name=pi0de
//    | OP name=pi0de
//    | m_d0ynq=d0ynq name=pi0de
//    | LPAREN m_p0atseq=p0atseq RPAREN
//        //    | LPAREN m_seq=s0argseq RPAREN
// //   |    m_srt=colons0rtopt kk=s0argseq colons0rtopt 
//    | QUOTELBRACKET m_p0atseq=p0atseq RBRACKET
//    | ATLPAREN m_p0atseq=p0atseq RPAREN
//    | QUOTELPAREN m_p0atseq=p0atseq RPAREN
//    | ATLBRACE m_labp0atseq=labp0atseq RBRACE
//    | QUOTELBRACE m_labp0atseq=labp0atseq RBRACE
//    | LBRACKET m_s0argseq=s0argseq RBRACKET
//    ; /* atmp0at */
    
labp0atseq:
    DOTDOTDOT {labp0atseq}
    | l0ab EQ m_p0at=p0at m_labp0atsseq=commalabp0atseq
    ;

commalabp0atseq: {labp0atseq}(COMMA l0ab EQ m_commalabp0atseq+=p0at)*
    ; /* commalabp0atseq */

p0atseq: {p0atseq}(m_p0at=p0at m_p0atseq=commabarp0atseq /* origin is commap0atseq */)?;
// p0atseqgo: {p0atseqgo}(m_p0at=p0atgo m_p0atseq=commabarp0atseqgo /* origin is commap0atseq */)?;

commabarp0atseq: {commabarp0atseq}((COMMA|BAR) m_commabarp0atseq+=p0at)*;
commabarp0atseqgo: {commabarp0atseqgo}((COMMA|BAR) m_commabarp0atseq+=p0atgo)*;

argp0atseq1: {argp0atseq1}(m_argp0at+=argp0at)+
	
;
argp0atseq: {argp0atseq}(m_argp0at+=argp0at)*
    ;
//argp0atseqgo: {argp0atseqgo}(m_argp0at+=argp0atgo)*
//    ;

argp0at:{argp0at}
    m_atmp0at=atmp0at
    | LBRACE m_s0vararg=s0vararg RBRACE
    ; /* argp0at */

//argp0atgo:{argp0atgo}
//    m_atmp0at=atmp0at
//    | LBRACE m_s0vararg=s0vararg RBRACE
//    ; /* argp0at */
    
s0vararg:
    m_dot=DOTDOT
    | m_dotdot=DOTDOTDOT
    | m_s0argseq=s0argseq
    ; /* s0vararg */

andd0cstdecseq: {andd0cstdecseq}(AND m_andd0cstdecseq+=d0cstdec)*
    ;

labd0expseq: {labd0expseq}(l0ab EQ m_d0exp=d0exp m_labd0expseq=commalabd0expseq)?;

commalabd0expseq: {commalabd0expseq}(COMMA l0ab EQ m_commalabd0expseq+=d0exp)*;



d0expcommabarseq: {d0expcommabarseq}(m_d0exp=d0exp m_d0expcommabarseq=commabard0expseq)?;

commabard0expseq: {commabard0expseq}((COMMA|BAR) m_commabard0expseq+=d0exp)*;

d0expsemiseq0: {d0expsemiseq0}(m_d0exp=d0exp (SEMICOLON m_d0expsemiseq0_rest=d0expsemiseq0)?)?;

d0expcommabarsemiseq: {d0expcommabarsemiseq}(m_d0exp=d0exp m_d0expseq=commabarsemid0expseq)?;

commabarsemid0expseq: {commabarsemid0expseq}((COMMA|BAR|SEMICOLON) (m_d0expseq+=d0exp)?)*;

gtlt_t1mps0expseqseq: {gtlt_t1mps0expseqseq}(GTLT m_x=t1mps0expseq m_seqgtlt=gtlt_t1mps0expseqseq)?;

t1mps0expseq: {t1mps0expseq}(m_first=t1mps0exp m_seqt1mp=commat1mps0expseq)?;
commat1mps0expseq: {commat1mps0expseq}(COMMA m_seq+=t1mps0exp)*;

// original this should be apps0exp which has some problem
// due to the fact that si0de contains '>' which conflects with
// the rule
// ==================
// tmpqi0de t1mps0expseq gtlt_t1mps0expseqseq GT  // related to template
// ==================
// A naive solution used below simply creates a special t1mpsi0de which
// doesn't have '<'

t1mps0exp: t1mpapps0exp
    ;
    
t1mpapps0exp:
    m_a=t1mpapps0expA | m_b=t1mpapps0expB | m_c=t1mpapps0expC
    ;

t1mpapps0expA:
    m_atmA=t1mpatms0expA m_t1mpapps0expA=t1mpapps0exp?;
    
t1mpapps0expB:
    m_atmB=t1mpatms0expB m_rest=(t1mpapps0expA|t1mpapps0expB)?;

t1mpapps0expC:
    m_atmC=t1mpatms0expC m_t1mpapps0expC=t1mpapps0exp?
    ;

t1mpatms0expA:
    m_content=LITERAL_char  // 'x'
    | m_content=LITERAL_int  // 23
    | m_content=LITERAL_intsp  // 23U
    | m_content=t1mpsi0de  // x
    | OP m_content=si0de  // op x
    | s0taq m_content=si0de  // $ABC.x
    | LPAREN m_s0expseq=s0expseq RPAREN  // (x, y, z)  or (x, y, z | a, b, c)
    | ATLPAREN m_s0expseq=s0expseq RPAREN  // @(x, y, z)  or @(x, y, z | a, b, c)
    | QUOTELPAREN m_s0expseq=s0expseq RPAREN  // '(x, y, z)  or '(x, y, z | a, b, c)
    | DLRTUP_T LPAREN m_s0expseq=s0expseq RPAREN  // $tup_t (x, y, z) or $tup_t (x, y, z | a, b, c)
    | DLRTUP_VT LPAREN m_s0expseq=s0expseq RPAREN  // $tup_vt (x, y, z)  or $tup_vt (x, y, z | a, b, c)
    | ATLBRACE m_labs0expseq=labs0expseq RBRACE  // @{x = 3, y = 4}
    | LBRACE m_labs0expseq=labs0expseq RBRACE  // {x = 3, y = 4}  // for this, I turned on the backtrack
    | QUOTELBRACE m_labs0expseq=labs0expseq RBRACE  // '{x = 3, y = 4}
    | RET_T LBRACE m_labs0expseq=labs0expseq RBRACE  // ret_t{x = 3, y = 4}
    | RET_VT LBRACE m_labs0expseq=labs0expseq RBRACE  // ret_vt{x = 3, y = 4}
    | DLREXTYPE_STRUCT STRING OF LBRACE m_labs0expseq=labs0expseq RBRACE  // $extype_struct "foo" of {x = x', y = y'}
//    | (ATLBRACKET s0exp RBRACKET) (LBRACKET s0expseq RBRACKET)+  // removed to atms0expB
    | MINUSLT m_e0fftagseq=e0fftagseq GT  // -<fun, ~1>
    | MINUSLTGT {t1mpatms0expA}
    | LBRACE m_s0quaseq=s0quaseq RBRACE
//    | (LBRACKET s0quaseq RBRACKET)  // removed to atms0expC
    | HASHLBRACKET m_s0quaseq=s0quaseq RBRACKET
    ;
t1mpatms0expB:
    ATLBRACKET m_exp=s0exp RBRACKET (LBRACKET m_seq_arr+=s0expseq RBRACKET)+ // @[x][x, y, z]
    ;
    
t1mpatms0expC:
    LBRACKET m_s0quaseq=s0quaseq RBRACKET
    ;

t1mpsi0de:
    ALNUMRIC_IDENTIFIER |  // x
    SYMBOLIC_IDENTIFIER |
    R0EAD |  // r@ead
    AMPERSAND |  // &
    BACKSLASH |  // \
    BANG |  // !
//    GT |  // >
    LT |  // <
    MINUSGT |  // ->
    TILDE  // ~
    ; /* t1mpsi0de */
    
tmpqi0de:
    tmpi0de  // foo<
    | d0ynq tmpi0de  // $A.foo<
    ;

tmpi0de: IDENTIFIER_tmp;  // TEMPLATE_IDENTIFIER  


s0elop:
    DOT
    | MINUSGT
    ;

d0arrind:
    m_seq=d0expcommaseq RBRACKET (LBRACKET m_rest=d0arrind)?
    ;

arrqi0de:
    m_arr=arri0de
    | m_d0ynq=d0ynq m_arr=arri0de
    ; /* arrqi0de */

arri0de: IDENTIFIER_arr;  // ARRAY_IDENTIFIE
  
d0expcommaseq: {d0expcommaseq}(m_d0exp=d0exp m_seq=commad0expseq)?;

commad0expseq: {commad0expseq}(COMMA m_seq+=d0exp)*;

s0expelt: {s0expelt}(LBRACE m_s0exp=s0exp RBRACE)?;

s0expdargseq: {s0expdargseq}(m_seq+=s0expdarg)*;

s0expdarg: LBRACE s0exparg RBRACE;

s0exparg:
    m_do2=DOTDOT // ..
    | m_dot3=DOTDOTDOT // ...
    | m_seq=s0expseq1
    ; /* s0exparg */



i0dext:
    IDENTIFIER_ext  // EXTERNAL_IDENTIFIER
    | DO  // do
    | WHILE  // while
    ;

m0acargseq: {m0acargseq} m_args+=m0acarg*;

m0acarg:
    m_m0arg=m0arg
    | LPAREN m_seq=m0argseq RPAREN
    ;
    
m0arg returns refentity:
	{m0arg} name=pi0de
;

pi0de:
    ALNUMRIC_IDENTIFIER
    | SYMBOLIC_IDENTIFIER
    ;

m0argseq: {m0argseq}(m_arg=m0arg m_seq=commam0argseq)?;

commam0argseq: {commam0argseq}(COMMA m_args+=m0arg)*;


dqi0de:
    di0de
    | d0ynq di0de
    ;

d0ynq:
    i0de_dlr (DOT|COLON)  // $A.
    | i0de_dlr i0de_dlr COLON  // $A $A :
    | DOLLAR STRING (DOT | i0de_dlr COLON)
    ;

ande0xndecseq: {ande0xndecseq}(AND m_seq+=e0xndec)*;

e0xndec returns refentity: 
    {e0xndec} m_conq0uaseq=conq0uaseq name=di0de m_cona0rgopt=cona0rgopt;

s0expdefseqopt: {s0expdefseqopt}(WHERE m_s0expdef+=s0expdef m_seq_t+=ands0expdefseq)*;

andd0atdecseq: {andd0atdecseq}(AND m_seq+=d0atdec)*;

d0atdec:
    m_si0de=si0de (LPAREN m_argseq=d0atargseq RPAREN)? EQ m_seq=d0atconseq
    ;

d0atconseq:
    m_d0atconseq=bard0atconseq
    | m_d0atcon=d0atcon m_d0atconseq=bard0atconseq
    ;

bard0atconseq: {bard0atconseq}(BAR m_seq+=d0atcon)*;


//d0atcon:
//    m_conq=conq0uaseq // {x:int} {xs:ilist} 
//    m_di0de=di0de  // glist_cons
//    m_coni0ndopt=coni0ndopt  // (a, cons (x, xs))
//    m_cona0rgopt=cona0rgopt  // of (E (a, x), glist (a, xs))
//    ;
d0atcon returns refentity:
	{d0atcon}
    myconq=conq0uaseq m_di0de=d0atcon_di0de m_coni0ndopt=coni0ndopt m_cona0rgopt=cona0rgopt  // of (E (a, x), glist (a, xs))
    ;

// add extra level to help handle semantic highlighting
d0atcon_di0de:
    name = di0de
    ;

cona0rgopt: {cona0rgopt}(OF m_exp=s0exp)?;

coni0ndopt: {coni0ndopt}(LPAREN m_seq=s0expseq RPAREN)?;

//di0de:
//    ALNUMRIC_IDENTIFIER
//    | SYMBOLIC_IDENTIFIER
//    | BACKSLASH  // \
//    | BANG  // !
//    | EQ  // =
//    | GT  // >
//    | GTLT  // ><
//    | LT  // <
//    | TILDE  // ~
//    ;
di0de: 
	pi0de
	| spi0de
;

refdi0de returns refentity:
	{refdi0de}name=di0de
;

spi0de:
	BACKSLASH  // \
	| =>BANG EQ  // !=  // todo: check whether this is coherent with ATS syntax
    | BANG  // !
    | EQ  // =
    | GT  // >
    | GTLT  // ><
    | LT  // <
    | TILDE  // ~
    ;
    
conq0uaseq: {conq0uaseq}(LBRACE m_s0quaseq=s0quaseq RBRACE m_rest=conq0uaseq)?;


datakind:
    DATAPROP  // "dataprop"
    | DATATYPE  // "datatype"
    | DATAVIEW  // "dataview"
    | DATAVIEWTYPE  // "dataviewtype"
    ;



s0aspdec:
    m_sqi0de=sqi0de m_s0args=s0argseqseq m_colons0rtopt=colons0rtopt EQ m_s0exp=s0exp
    ;

sqi0de:
    m_si0de=si0de
    | m_s0taq=s0taq m_si0de=si0de
    ; /* sqi0de */


ands0expdefseq: {ands0expdefseq}(AND m_seq+=s0expdef)*;

s0expdef: 
	m_si0de=si0de m_seq=s0argseqseq m_colons0rtopt=colons0rtopt EQ m_exp=s0exp
    ;

stadefkind:
    STADEF  // "stadef"
    | PROPDEF  // "propdef"
    | TYPEDEF  // "typedef"
    | VIEWDEF  // "viewdef"
    | VIEWTYPEDEF  // "viewtypedef"
    ; /* stadefkind */



ands0tavarseq: {ands0tavarseq}(AND m_seq+=s0tavar)*;

s0tavar: m_si0de=si0de COLON m_s0rt=s0rt;  // x: int

ands0tacstseq: {ands0tacstseq}(AND m_s+=s0tacst)*;

s0tacst:
    m_si0de=si0de (LPAREN m_seq=d0atargseq RPAREN)? COLON m_s0rt=s0rt;


ands0taconseq: {ands0taconseq}(AND m_seq+=s0tacon)*;

s0tacon:
    m_si0de=si0de (LPAREN m_seq=d0atargseq RPAREN)? (EQ m_s0exp=s0exp)?
    ; /* s0tacon */

d0atargseq: {d0atargseq}(m_arg=d0atarg m_rest=commad0atargseq)?;  // x: int, y: char

commad0atargseq: {commad0atargseq}(COMMA m_argss+=d0atarg)*;

d0atarg:
    m_s0rt=s0rtpol
    | m_i0de=i0de COLON m_s0rt=s0rtpol
    ; /* d0atarg */

s0rtpol:
    m_s0rt=s0rt
    | m_type=PROPMINUS  // "prop-"
    | m_type=PROPPLUS  // "prop+"
    | m_type=TYPEMINUS  // "type-"
    | m_type=TYPEPLUS  // "type+"
    | m_type=T0YPEMINUS  // "t@ype-"
    | m_type=T0YPEPLUS  // "t@ype+"
    | m_type=VIEWMINUS  // "view-"
    | m_type=VIEWPLUS  // "view+"
    | m_type=VIEWTYPEMINUS  // "viewtype-"
    | m_type=VIEWTYPEPLUS  // "viewtype+"
    | m_type=VIEWT0YPEMINUS  // "viewt@ype-"
    | m_type=VIEWT0YPEPLUS  // "viewt@ype+"
    ;

abskind:
    ABSPROP  // "absprop"
    | ABSTYPE  // "abstype"
    | ABST0YPE  // "abst@ype"
    | ABSVIEW  // "absview"
    | ABSVIEWTYPE  // "absviewtype"
    | ABSVIEWT0YPE  // "absviewt@ype"
    ; /* abskind */



andd0atsrtdecseq: {andd0atsrtdecseq}(AND myseq+=d0atsrtdec)*;

d0atsrtdec: 
	m_d0de=i0de EQ m_seq=d0atsrtconseq
;

d0atsrtconseq:
    m_seq=bard0atsrtconseq
    | m_ele=d0atsrtcon m_seq=bard0atsrtconseq
    ; /* d0atsrtconseq */

bard0atsrtconseq: {bard0atsrtconseq}(BAR m_seq+=d0atsrtcon)*;

d0atsrtcon:
    m_i0de=i0de  // nil
    | m_i0de=i0de OF m_s0rt=s0rt  // cons of (int, ilist)
    ;

ands0rtdefseq: {ands0rtdefseq}(AND m_seq+=s0rtdef)*;

s0rtdef:
    m_id=s0rtid EQ m_ext=s0rtext  // x = y
    ;


// for reduce the size of the file seperate no todo no
// The rest part is for static
// remove the content of the file from the beginning to this line actually remove
// all the dynamic part 

s0exp: 
    (m_apps0exp=apps0exp (COLON s0rtext)?
    | m_exts0exp=exts0exp (COLON s0rtext)?
    | LAM  m_seq=s0argseqseq m_colons0rtopt=colons0rtopt EQGT m_body=s0exp //  zhiqiang: different from desc
    )
    ;
    
s0rtext:
    m_sort=s0rt  // x
    // {y: int | x > 3; y > 4}
    | LBRACE m_id=si0de COLON m_ext=s0rtext BAR m_s0exp1+=s0exp ((BAR|SEMICOLON) m_s0exp2+=s0exp)* RBRACE
    ;
    
s0argseqseq:{s0argseqseq}
     (m_si0de=si0de m_seq=s0argseqseq
     | LPAREN m_seq=s0argseq RPAREN m_seqseq=s0argseqseq  // (x: int, y: char)
     )?
     ; /* s0argseqseq */

s0argseq: {s0argseq}(m_s0arg=s0arg m_seq=commas0argseq)?;

commas0argseq: {commas0argseq}(COMMA m_s0args+=s0arg)*;


s0arg: 
	m_si0de=si0de m_s0rt=colons0rtopt
; /* s0arg */

colons0rtopt: {colons0rtopt}(COLON m_s0rt=s0rt)?;

// This is different from desc.
apps0exp:
    m_a=apps0expA|m_b=apps0expB|m_c=apps0expC
    ;

apps0expA:
    m_Afirst=atms0expA m_Arest=apps0exp?;
    
apps0expB:
    m_Bfirst=atms0expB m_Brest=(apps0expA|apps0expB)?;

apps0expC:
    m_Cfirst=atms0expC m_Crest=apps0exp?;


exts0exp: 
    DLREXTYPE m_e0exp=STRING m_app=apps0exp?
    ;

atms0expA:
    {atms0expA_base}m_content=LITERAL_char  // 'x'
    | {atms0expA_base}m_content=LITERAL_int  // 23
    | {atms0expA_base}m_content=LITERAL_intsp  // 23U
    | {atms0expA_base}m_atmspexpA_si0de=si0de // x
    | {atms0expA_comp}OP m_atmspexpA_si0de=si0de  // op x
    | {atms0expA_base}s0taq m_atmspexpA_si0de=si0de  // $ABC.x
    | {atms0expA_comp}LPAREN m_s0expseq=s0expseq RPAREN  // (x, y, z)  or (x, y, z | a, b, c)
    | {atms0expA_comp}ATLPAREN m_s0expseq=s0expseq RPAREN  // @(x, y, z)  or @(x, y, z | a, b, c)
    | {atms0expA_comp}QUOTELPAREN m_s0expseq=s0expseq RPAREN  // '(x, y, z)  or '(x, y, z | a, b, c)
    | {atms0expA_comp}DLRTUP_T LPAREN m_s0expseq=s0expseq RPAREN  // $tup_t (x, y, z) or $tup_t (x, y, z | a, b, c)
    | {atms0expA_comp}DLRTUP_VT LPAREN m_s0expseq=s0expseq RPAREN  // $tup_vt (x, y, z)  or $tup_vt (x, y, z | a, b, c)
    | {atms0expA_comp}ATLBRACE m_labs0expseq=labs0expseq RBRACE  // @{x = 3, y = 4}
    | {atms0expA_comp}LBRACE m_labs0expseq=labs0expseq RBRACE  // {x = 3, y = 4}  // for this, I turned on the backtrack
    | {atms0expA_comp}QUOTELBRACE m_labs0expseq=labs0expseq RBRACE  // '{x = 3, y = 4}
    | {atms0expA_comp}RET_T LBRACE m_labs0expseq=labs0expseq RBRACE  // ret_t{x = 3, y = 4}
    | {atms0expA_comp}RET_VT LBRACE m_labs0expseq=labs0expseq RBRACE  // ret_vt{x = 3, y = 4}
    | {atms0expA_comp}DLREXTYPE_STRUCT m_literal=STRING OF LBRACE m_labs0expseq=labs0expseq RBRACE  // $extype_struct "foo" of {x = x', y = y'}
//    | (ATLBRACKET s0exp RBRACKET) (LBRACKET s0expseq RBRACKET)+  // removed to atms0expB
    | {atms0expA_comp}MINUSLT m_e0fftagseq=e0fftagseq GT  // -<fun, ~1>
    | {atms0expA_comp}MINUSLTGT {atms0expA}
    | {atms0expA_comp}LBRACE (m_s0quaseq=s0quaseq) RBRACE
//    | (LBRACKET s0quaseq RBRACKET)  // removed to atms0expC
    | {atms0expA_comp}HASHLBRACKET m_s0quaseq=s0quaseq RBRACKET
    ;
    
atms0expB:
    ATLBRACKET m_s0exp=s0exp RBRACKET (LBRACKET m_atms0expBseq+=s0expseq RBRACKET)+ // @[x][x, y, z]
    ;
    
atms0expC:
    LBRACKET m_seq=s0quaseq RBRACKET
    ;

//



s0quaseq: {s0quaseq}(m_s0qua=s0qua ((BAR|SEMICOLON) m_s0quaseq+=s0qua)*)?;

//// The origin is 
//s0qua ::= 
//  | apps0exp
//  | si0de commasi0deseq ":" s0rtext
//; /* s0qua */
//// This is not LL, becuase apps0exp can also be si0de
//s0qua:
//    name=LITERAL_char  // 'x'
//    | name=LITERAL_int  // 23
//    | name=LITERAL_intsp  // 23U
//    | name=si0de m_rest=commasi0deseq COLON m_ext=s0rtext // zhiqiang: different from desc
//    | OP name=si0de  // op x
//    | s0taq m_s0qua_si0de=si0de  // $ABC.x
//    | LPAREN m_s0expseq=s0expseq RPAREN  // (x, y, z)  or (x, y, z | a, b, c)
//    | ATLPAREN m_s0expseq=s0expseq RPAREN  // @(x, y, z)  or @(x, y, z | a, b, c)
//    | QUOTELPAREN m_s0expseq=s0expseq RPAREN  // '(x, y, z)  or '(x, y, z | a, b, c)
//    | DLRTUP_T LPAREN m_s0expseq=s0expseq RPAREN  // $tup_t (x, y, z) or $tup_t (x, y, z | a, b, c)
//    | DLRTUP_VT LPAREN m_s0expseq=s0expseq RPAREN  // $tup_vt (x, y, z)  or $tup_vt (x, y, z | a, b, c)
//    | ATLBRACE m_labs0expseq=labs0expseq RBRACE  // @{x = 3, y = 4}
//    | QUOTELBRACE m_labs0expseq=labs0expseq RBRACE  // '{x = 3, y = 4}
//    | RET_T LBRACE m_labs0expseq=labs0expseq RBRACE  // ret_t{x = 3, y = 4}
//    | RET_VT LBRACE m_labs0expseq=labs0expseq RBRACE  // ret_vt{x = 3, y = 4}
//    | DLREXTYPE_STRUCT STRING OF LBRACE m_labs0expseq=labs0expseq RBRACE  // $extype_struct "foo" of {x = x', y = y'}
//    | ATLBRACKET m_s0exp=s0exp RBRACKET (LBRACKET m_atlbracketseq+=s0expseq RBRACKET)+  // @[x][x, y, z]
//    | MINUSLT m_e0fftagseq=e0fftagseq GT  // -<fun, ~1>
//    | MINUSLTGT {s0qua}
//    | LBRACE m_s0quaseq=s0quaseq RBRACE
//    | LBRACKET m_s0quaseq=s0quaseq RBRACKET
//    | HASHLBRACKET m_s0quaseq=s0quaseq RBRACKET
//    ; 
    
s0qua:
	m_apps0exp=apps0exp
	| m_name1=si0de m_namerest=commasi0deseq COLON m_s0rtext=s0rtext
;

commasi0deseq: {commasi0deseq}(COMMA m_seq+=si0de)*;  // , x, y, z
 
e0fftagseq: {e0fftagseq}(m_ele=e0fftag m_rest=commae0fftagseq)?;  // fun, ~x

e0fftag:
    BANG e0ffid  // !
  | TILDE e0ffid  // ~
  | e0ffid  // y
  | 'fun'  // fun
  | LITERAL_int  // 4
; /* e0fftag */

commae0fftagseq: {commae0fftagseq}(COMMA m_seq+=e0fftag)*;

e0ffid: ALNUMRIC_IDENTIFIER;  // x


labs0expseq: {labs0expseq}(l0ab EQ m_commalabs0expseq=s0exp m_labcommaseq=commalabs0expseq)?;

commalabs0expseq:
	{commalabs0expseq}(COMMA l0ab EQ m_commalabsrest+=s0exp)*
	;
	
l0ab:
    i0de
    | LITERAL_int
    | LPAREN l0ab RPAREN
	; /* l0ab */


s0expseq: {s0expseq}m_s0expseq1=s0expseq1?;

s0expseq1: m_ele=s0exp m_rest=commabars0expseq
    ; 

commas0expseq: {commas0expseq}(COMMA m_s0exp+=s0exp)*;

BARCOMMA: BAR | COMMA;

commabars0expseq:{commabars0expseq}
    (=>BARCOMMA m_commabarseq+=s0exp?)*
    ;

s0taq:  // qualified name
    i0de_dlr DOT |  // $ABC.
    i0de_dlr COLON |  // $ATS:
    DOLLAR STRING DOT  // $"xxx".
    ;

si0de:
    ALNUMRIC_IDENTIFIER |  // x
    SYMBOLIC_IDENTIFIER |
    R0EAD |  // r@ead
    AMPERSAND |  // &
    BACKSLASH |  // \
    BANG |  // !
    GT |  // >
    LT |  // <
    MINUSGT |  // ->
    TILDE  // ~
    ; /* si0de */

    

s0rt: m_seq+=atms0rt+; 

atms0rt:
    m_s0rtid=s0rtid |  // x
    m_s0rtq=s0rtq m_s0rtid=s0rtid |  // $AAA.xxx
    LPAREN m_seq=s0rtseq RPAREN |  // (x, y, z)
    ATLPAREN m_seq=s0rtseq RPAREN  // @(x, y, z)
    ;

s0rtseq: {s0rtseq}(m_s0rt=s0rt m_seq=commas0rtseq)?;

commas0rtseq: {commas0rtseq}(COMMA m_seq+=s0rt)*;

s0rtq:  // q means qualified name?
    i0de_dlr DOT |  // $abc.
    DOLLAR STRING DOT  // $"abc".
    ;

i0de_dlr: IDENTIFIER_dlr;  // starting with $
    
        


s0rtid:
    ALNUMRIC_IDENTIFIER | 
    SYMBOLIC_IDENTIFIER |
    T0YPE |  // t@ype
    VIEWT0YPE |  // viewt@ype
    BACKSLASH |  // \
    MINUSGT |  // ->
    MINUSLTGT  // -<>
    ; /* s0rtid */



e0xp: atme0xp+;

atme0xp:
    LITERAL_char |
    LITERAL_float |
    LITERAL_int |
    STRING |
    i0de |
    LPAREN e0xpseq RPAREN
    PERCENTLPAREN e0xp RPAREN  // %(
    ;

e0xpseq: (e0xp commae0xpseq)?;

commae0xpseq: (COMMA e0xp)*;
 
e0xpopt: e0xp?;





p0rec:
    (LITERAL_int |  // 3
    LPAREN i0de RPAREN |  // (x)
    LPAREN i0de SYMBOLIC_IDENTIFIER LITERAL_int RPAREN  // (x > 4)
    )*;
	
i0deseq:
    {i0deseq} m_i0des+=refi0de*;

refi0de returns refentity:
	{refi0de} name=i0de
;
	
i0de:
    ALNUMRIC_IDENTIFIER
    | SYMBOLIC_IDENTIFIER
    | AMPERSAND  // &
    | BACKSLASH  // \
    | BANG  // !
    | EQ  // =
    | GT  // >
    | GTLT  // ><
    | LT  // <
    | MINUSGT  // ->
    | MINUSLTGT  // -<>
    | TILDE  // ~
    ;
	
	

/* \f: \014; \t: 011; \r: \015 */
// Xtext doesn't support \f
terminal BLANKS: ('\r'|'\n'|'\t'|' ')+;

terminal AMPERSAND: '&';
terminal BACKQUOTE: '`';
terminal BANG: '!';
terminal BAR: '|';
terminal COLON: ':';
terminal DOLLAR: '$';
terminal DOT: '.';
terminal EQ: '=';
terminal HASH: '#';
terminal TILDE: '~';
terminal DOTDOT: '..';
terminal DOTDOTDOT: '...';
terminal EQGT: '=>';  // implication without decoration
terminal EQLT: '=<';  // implication decoration
terminal EQLTGT: '=<>';  // implication with empty decoration
terminal EQSLASHEQGT: '=/=>';
terminal EQGTGT: '=>>';
terminal EQSLASHEQGTGT: '=/=>>';
terminal LT: '<';
terminal GT: '>';
terminal GTLT: '><';
terminal DOTLT: '.<';
terminal GTDOT: '>.';  // .<...>. : metric
terminal DOTLTGTDOT: '.<>.';
terminal MINUSGT: '->';  // implication
terminal MINUSLT: '-<';  // -<...> : decorated implication
terminal MINUSLTGT: '-<>';
terminal COLONLT: ':<';  // :<...> : decorated implication
terminal COLONLTGT: ':<>';

terminal ABSPROP: 'absprop';
terminal ABSTYPE: 'abstype';
terminal ABSVIEW: 'absview';
terminal ABSVIEWTYPE: 'absviewtype';
terminal AND: 'and';
terminal AS: 'as';
terminal ASSUME: 'assume';
terminal BEGIN: 'begin';
terminal BREAK: 'break';
terminal CASE: 'case';
//terminal CASTFN: 'castfn';
terminal CLASSDEC: 'classdec';
terminal CONTINUE: 'continue';
terminal DATASORT: 'datasort';
terminal DATAPARASORT: 'dataparasort';
terminal DATAPROP: 'dataprop';
terminal DATATYPE: 'datatype';
terminal DATAVIEW: 'dataview';
terminal DATAVIEWTYPE: 'dataviewtype';
terminal DO: 'do';
terminal DYN: 'dyn';
terminal DYNLOAD: 'dynload';
terminal ELSE: 'else';
terminal END: 'end';
terminal EXCEPTION: 'exception';
terminal EXTERN: 'extern';
terminal FIX: 'fix';
terminal FN: 'fn';
terminal FOR: 'for';
//terminal FUN: 'fun';
terminal IF: 'if';
terminal IMPLEMENT: 'implement';
terminal IN: 'in';
terminal INFIX: 'infix';
terminal INFIXL: 'infixl';
terminal INFIXR: 'infixr';
terminal LAM: 'lam';
terminal LET: 'let';
terminal LLAM: 'llam';
terminal LOCAL: 'local';
terminal MACDEF: 'macdef';
terminal MACRODEF: 'macrodef';


terminal NONFIX: 'nonfix';
terminal OVERLOAD: 'overload';
terminal PAR: 'par';
terminal POSTFIX: 'postfix';
//terminal PRAXI: 'praxi';
terminal PREFIX: 'prefix';
terminal PRFN: 'prfn';
//terminal PRFUN: 'prfun';
//terminal PRVAL: 'prval';
terminal OF: 'of';
terminal OP: 'op';
terminal PROPDEF: 'propdef';
terminal REC: 'rec';
terminal SCASE: 'scase';
terminal SIF: 'sif';
terminal SORTDEF: 'sortdef';
terminal STA: 'sta';
terminal STADEF: 'stadef';
terminal STAIF: 'staif';
terminal STALOAD: 'staload';
terminal STAVAR: 'stavar';

terminal SYMELIM: 'symelim';
terminal SYMINTR: 'symintr';
terminal THEN: 'then';
terminal TRY: 'try';
terminal TYPEDEF: 'typedef';


terminal RET_T: 'ret_t';
terminal RET_VT: 'ret_vt';


//terminal VAL: 'val';
terminal VAR: 'var';
terminal VIEWDEF: 'viewdef';
terminal VIEWTYPEDEF: 'viewtypedef';
terminal WHEN: 'when';
terminal WHERE: 'where';
terminal WHILE: 'while';
terminal WITH: 'with';
terminal WITHPROP: 'withprop';
terminal WITHTYPE: 'withtype';
terminal WITHVIEW: 'withview';
terminal WITHVIEWTYPE: 'withviewtype';
//
terminal DLRARRSZ: '$arrsz';
terminal DLRDECRYPT: '$decrypt';
terminal DLRDELAY: '$delay';
terminal DLRDYNLOAD: '$dynload';

terminal DLREFFMASK_ALL: '$effmask_all';
terminal DLREFFMASK_EXN: '$effmask_exn';
terminal DLREFFMASK_NTM: '$effmask_ntm';
terminal DLREFFMASK_REF: '$effmask_ref';
terminal DLREXTERN: '$extern';
terminal DLREXTVAL: '$extval';
terminal DLREXTYPE: '$extype';
terminal DLREXTYPE_STRUCT: '$extype_struct';
terminal DLRENCRYPT: '$encrypt';


terminal DLRLDELAY: '$ldelay';  // linear $delay
terminal DLRLST: '$lst'|'$lst_t';
terminal DLRLST_VT: '$lst_vt';
terminal DLRRAISE: '$raise';
terminal DLRREC_T: '$rec_t';
terminal DLRREC_VT: '$rec_vt';
terminal DLRTUP_T: '$tup_t';
terminal DLRTUP_VT: '$tup_vt';
terminal DLRTYPEOF: '$typeof';

terminal SRPASSERT: '#assert';
terminal SRPDEFINE: '#define';
terminal SRPELIF: '#elif';
terminal SRPELIFDEF: '#elifdef';
terminal SRPELIFNDEF: '#elifndef';
terminal SRPELSE: '#else';
terminal SRPENDIF: '#endif';
terminal SRPERROR: '#error';
terminal SRPIF: '#if';
terminal SRPIFDEF: '#ifdef';
terminal SRPIFNDEF: '#ifndef';
terminal SRPINCLUDE: '#include';
terminal SRPPRINT: '#print';
terminal SRPTHEN: '#then';
terminal SRPUNDEF: '#undef';
//
terminal SRPFILENAME: '#FILENAME';
terminal SRPLOCATION: '#LOCATION';
terminal SRPCHARCOUNT: '#CHARCOUNT';
terminal SRPLINECOUNT: '#LINECOUNT';

terminal CASEMINUS: "case-";
terminal CASEPLUS:  "case+";
terminal FNSTAR:    "fn*";

// terminal METHODSTAR: "method*";
//
terminal FORSTAR:   "for*";
terminal WHILESTAR: "while*";
//
terminal ABST0YPE:      "abst@ype";
terminal ABSVIEWT0YPE:  "absviewt@ype";
//
terminal PROPPLUS:  "prop+";
terminal PROPMINUS: "prop-";
terminal TYPEPLUS:  "type+";
terminal TYPEMINUS: "type-";
terminal T0YPE:     "t@ype";
terminal T0YPEPLUS: "t@ype+";
terminal T0YPEMINUS:"t@ype-";
//
terminal VIEWPLUS:      "view+";
terminal VIEWMINUS: "view-";
terminal VIEWTYPEPLUS:  "viewtype+";
terminal VIEWTYPEMINUS: "viewtype-";
terminal VIEWT0YPE:     "viewt@ype";
terminal VIEWT0YPEPLUS: "viewt@ype+";
terminal VIEWT0YPEMINUS:"viewt@ype-";
//
terminal VALPLUS: "val+";
terminal VALMINUS: "val-";
//
terminal FOLDAT: "fold@";
terminal FREEAT: "free@";
terminal VIEWAT: "view@";
//
terminal ATLAM:  "@lam";
terminal ATLLAM: "@llam";
terminal ATFIX:  "@fix";
//
terminal R0EAD: "r@ead";

terminal COMMENT_REST: '////' ANYOTHER*;
terminal COMMENT_LINE: '//' !('\n'|'\r')* ('\r'? '\n')?;
terminal COMMENT_CLIKE: '/*' -> '*/';
// terminal COMMENT0:     '(*' -> '*)';
terminal COMMENT0:
	'(*' (!'*'|'*'+!('*'|')'))* '*'* ')'
;

// support (* aaa (* bbb *) ddd (* eee *) fff *)
terminal COMMENT1:
	'(*' 
	
	(
		(!('*'|'(')  |  '('+(!('('|'*'))  |  '*'+(!('*'|')'|'('))  |  '*'+'('+(!('*'|'('|')')))* '*'*  // misc
		'('+'*'  // (* -> (*
		(!'*'|'*'+!('*'|')'))* '*'+ ')'  // -> *)
	)+
	
	(!'*'|'*'+!('*'|')'))* '*'+ ')'+   // -> *)
;


terminal ALNUMRIC_IDENTIFIER:  // IDENTIFIER_alp in ats_lexer.lats
    ('A'..'Z'|'a'..'z'|'_') ('0'..'9'|'A'..'Z'|'a'..'z'|'_'|"'")*;

terminal IDENTIFIER_arr: 
    ('A'..'Z'|'a'..'z'|'_') ('0'..'9'|'A'..'Z'|'a'..'z'|'_'|"'")* '[';

terminal IDENTIFIER_tmp: 
    ('A'..'Z'|'a'..'z'|'_') ('0'..'9'|'A'..'Z'|'a'..'z'|'_'|"'")* '<';

terminal IDENTIFIER_ext: 
    ('A'..'Z'|'a'..'z'|'_') ('0'..'9'|'A'..'Z'|'a'..'z'|'_'|"'")* '!';

terminal IDENTIFIER_dlr: 
    '$' ('A'..'Z'|'a'..'z'|'_') ('0'..'9'|'A'..'Z'|'a'..'z'|'_'|"'")*;
    
terminal IDENTIFIER_srp: 
    '#' ('A'..'Z'|'a'..'z'|'_') ('0'..'9'|'A'..'Z'|'a'..'z'|'_'|"'")*;
    
terminal SYMBOLIC_IDENTIFIER:  // IDENTIFIER_sym in ats_lexer.lats
    ('%'|'&'|'+'|'-'|'.'|'/'|':'|'='|'@'|'~'|'`'|'^'|'|'|'*')+ |
    (('%'|'&'|'+'|'-'|'.'|'/'|':'|'='|'@'|'~'|'`'|'^'|'|'|'*')* ('<'|'>')
      ('%'|'&'|'+'|'-'|'.'|'/'|':'|'='|'@'|'~'|'`'|'^'|'|'|'*'|'<'|'>')*) |
    (('%'|'&'|'+'|'-'|'.'|'/'|':'|'='|'@'|'~'|'`'|'^'|'|'|'*')* ('$'|'#'|'?')
      ('%'|'&'|'+'|'-'|'.'|'/'|':'|'='|'@'|'~'|'`'|'^'|'|'|'*'|'$'|'#'|'?')*)
    ;
    
terminal LITERAL_int:
    '~'? (('0'..'9')+ | '0' ('x'|'X') ('0'..'9')+)
    ;

terminal LITERAL_intsp:
    LITERAL_int ('l'|'L'|'u'|'U')+;

terminal LITERAL_float:
    (('0'..'9')+ ('e'|'E')('+'|'-')? ('0'..'9')+) |
    (('0'..'9')+ '.' ('0'..'9')* (('e'|'E') ('+'|'-')? ('0'..'9')+)?)
    ;

terminal LITERAL_floatsp:
    LITERAL_float ('d'|'D'|'f'|'F'|'l'|'L');
    
terminal LPAREN:    '(';
terminal RPAREN:    ')';
terminal LBRACKET:  '[';
terminal RBRACKET:  ']';
terminal LBRACE:    '{';
terminal RBRACE:    '}';
terminal QUOTELPAREN:   "'(";
terminal QUOTELBRACKET: "'[";
terminal QUOTELBRACE:   "'{";
terminal ATLPAREN:  '@(';
terminal ATLBRACKET:'@[';
terminal ATLBRACE:  '@{';
terminal HASHLPAREN:'#(';
terminal HASHLBRACKET: '#[';
terminal HASHLBRACE: '#{';
terminal COMMA: ',';
terminal SEMICOLON: ';';
terminal BACKSLASH: '\\';
terminal BACKQUOTELPAREN: '`(';  // macro syntax
terminal COMMALPAREN: ',(';  // macro syntax
terminal PERCENTLPAREN: '%(';  // macro syntax
  
//terminal SATS_STRING:
//    '"' ( '\\' ('n'|'t'|'v'|'b'|'r'|'f'|'a'|'\\'|'?'|'\''|'"'|'('|'['|'{'|('\r'? '\n')|('0'..'9')) |
//    !('\\'|'"') )* '.sats"'
//;

terminal STRING:
    '"' ( '\\' ('n'|'t'|'v'|'b'|'r'|'f'|'a'|'\\'|'?'|'\''|'"'|'('|'['|'{'|('\r'? '\n')|('0'..'9')) |
    !('\\'|'"') )* '"'
;

terminal LITERAL_char:
	"'" (('\\' .) | !('\\'|'\''))+ "'"
;

// todo cannot handle %{%%}, but seems not important
terminal LITERAL_extcode:
    '%{' (('%' (!'}'))|(!'%'))* '%}'
    ;
   
// must place in the end
terminal ANYOTHER: .;


