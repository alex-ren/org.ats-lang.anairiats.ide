/*
 * generated by Xtext
 */
package org.ats_lang.ui.outline;

import org.ats_lang.anairiatsSats.andd0cstdecseq;
import org.ats_lang.anairiatsSats.d0cstdec;
import org.ats_lang.anairiatsSats.d0ec_sta;
import org.ats_lang.anairiatsSats.d0ecargseq;
import org.ats_lang.anairiatsSats.d0ecseq_sta;
import org.ats_lang.anairiatsSats.d0ecseq_sta_rev;
import org.ats_lang.anairiatsSats.dcstkind;
import org.ats_lang.anairiatsSats.satprogram;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.AbstractElement;
import org.eclipse.xtext.ui.editor.outline.IOutlineNode;
import org.eclipse.xtext.ui.editor.outline.impl.DefaultOutlineTreeProvider;
import org.eclipse.xtext.ui.editor.outline.impl.DocumentRootNode;

/**
 * customization of the default outline structure
 * 
 */
public class AnairiatsSatsOutlineTreeProvider extends
		DefaultOutlineTreeProvider {
	protected void _createChildren(DocumentRootNode parentNode,
			satprogram staprog) {
		d0ecseq_sta a1 = staprog.getM_sta();
		if (a1 == null) {
			System.out.println("a1 == null");
			return;
		}
		createNode(parentNode, a1);

	}

	protected void _createChildren(IOutlineNode parentNode, d0ecseq_sta seq) {
		d0ecseq_sta_rev a2 = seq.getM_d0ecseq_sta_rev();
		if (a2 == null) {
			System.out.println("a2 == null");
			return;
		}

		EList<d0ec_sta> lst = a2.getM_d0ec_sta();
		if (lst == null) {
			System.out.println("lst");
			return;
		}
		for (d0ec_sta n : lst) {
			createNode(parentNode, n);
		}
	}
    
	protected void _createChildren(IOutlineNode parentNode, d0ec_sta ele) {
		/* m_d0ec=d0ec */
		if (ele.getM_d0ec() != null) {
			System.out.println("dddddddddddddddddddddddddd");
		}
			
		/* m_kind=dcstkind */
		dcstkind m_kind = ele.getM_kind();
		if (m_kind != null) {
			createNode(parentNode, ele.getM_tmparg());
			createNode(parentNode, ele.getM_d0cstdec());
			andd0cstdecseq seq = ele.getM_seq();
			EList<d0cstdec> declst = seq.getM_andd0cstdecseq();
			for (d0cstdec dec: declst) {
			    createNode(parentNode, dec);
			}
		}
	}
	
//    m_d0ec=d0ec
//    | m_kind=dcstkind// fun
//      m_tmparg=d0ecargseq  // {n: type}
//      m_d0cstdec=d0cstdec   // foo {k: int} (x: int k):<fun> int = "xxx"
//      m_seq=andd0cstdecseq  // 
//    | m_extcode=LITERAL_extcode
//    | srpifkind guad0ec_sta  // #ifdef X #then ... #elif ... #else ... #endif
//    | SRPINCLUDE m_include=LITERAL_string
//    | LOCAL m_local=d0ecseq_sta IN m_body=d0ecseq_sta END

}
